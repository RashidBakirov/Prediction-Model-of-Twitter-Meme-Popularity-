# -*- coding: utf-8 -*-
"""Distance_Feature.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17GYNRR7_QUuhY9EUwxQGpX2LnsGKcIT6
"""

from collections import defaultdict
from collections import deque
import csv
import pandas as pd
import json
import random
import math

data = pd.read_excel('socialnetwrokdataset.xlsx')
data = data.drop(["Unnamed: 0"], axis = 1)

early_adopters = list(set(data['user_id']))

len(early_adopters)

# Opening JSON file 
g = open('/content/drive/My Drive/followers/merged_file.json',) 
  
# returns JSON object as  
# a dictionary 
pair_users = json.load(g)

len(pair_users)

graph = {}
for k, v in pair_users:
  graph.setdefault(v, [])
  graph.setdefault(k, []).append(v)

graph

with open('grap00h.json','w') as f: 
  json.dump(graph, f)

len(graph.keys())

#to try the code
#graph = {'A': ['B', 'C', 'E'],
         #'B': ['A','D', 'E'],
         #'C': ['A', 'F', 'G'],
         #'D': ['B'],
         #'E': ['A', 'B','D'],
         #'F': ['C'],
         #'G': ['C']}

class bfs_shortest_path:

    def __init__(self, graph):
        self.graph = graph

    def check_distance(self, start, end):
        queue = deque([(start, 0)])
        seen = set()
        while queue:
            node, distance = queue.popleft()
            if node in seen:
                continue
            seen.add(node)
            if node == end:
                return distance
            for adjacent in self.graph.get(node, []):
                queue.append((adjacent, distance + 1))

bfs = bfs_shortest_path(graph)

#bfs_shortest_path.check_distance('A', 'B') # to try

shortest_path = []

for i in range(len(early_adopters)-1):
  try: 
    shortest_path.append(bfs.check_distance(early_adopters[i], early_adopters[i+1]))
  except:
    continue

shortest_path

#avarage step distance 
avg = sum(shortest_path)/(len(early_adopters)-1)  

#CV of step distance
std = math.sqrt((sum(shortest_path)- avg**2)/(len(nodes)-2))
cv = std/avg

# Diameter feature
diameter = max(shortest_path)

print(f'The avarage of step distance: {avg}')
print(f'The CV of step distance: {cv}')
print(f'Diameter: {diameter}')